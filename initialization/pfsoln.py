'''
MATPOWER
Copyright (c) 1996-2016 by Power System Engineering Research Center (PSERC) by Ray Zimmerman, PSERC Cornell
This code follows part of MATPOWER.
See http://www.pserc.cornell.edu/matpower/ for more info.
Modified by Oak Ridge National Laboratory (Byungkwon Park) to be used in the parareal algorithm
'''
import numpy as np
import scipy.sparse as sp
from scipy.sparse import csr_matrix, csc_matrix, lil_matrix, identity

def pfsoln(baseMVA, bus, gen, branch, Ybus, Yf, Yt, V, ref, pv, pq,):

    ## ----- update Qg for gens at PV / slack buses and Pg for slack bus(es) -----
    row = gen[:, 0].toarray().reshape(-1) - 1
    onon = np.logical_and(gen[:, 7].toarray() > 0, bus[row, 1].toarray() > 1)
    onon = np.where(onon == True)[0]
    off = sp.find(gen[:, 7].toarray() <= 0)[0]
    ggbus = gen[onon, 0].toarray().astype('int64') - 1

    ## compute total injected bus powers
    Sinj = V[ggbus.reshape(-1)] * np.conj(Ybus.tocsr()[ggbus.reshape(-1), :] * V)
    gen[off, 2] = np.zeros((len(off), 1))

    ## update Qg for generators at PV / slack buses
    Pdbus = bus[ggbus, 2].toarray().reshape(-1)
    Qdbus = bus[ggbus, 3].toarray().reshape(-1)
    #pg_sol = Sinj.real + Pdbus / baseMVA
    gen[onon, 2] = Sinj.imag*baseMVA + Qdbus

    ## at this point any buses with more than one generator will have
    ## the total Q dispatch for the bus assigned to each generator.This
    ## must be split between them. We do it first equally, then in proportion
    ## to the reactive range of the generator.

    ##
    nb = len(V)
    ngon = len(onon)
    row = np.arange(ngon)
    col = ggbus.reshape(-1)
    data = np.ones(ngon)
    Cg = csc_matrix((data, (row, col)), shape=(ngon, nb))

    ## divide Qg by number of generators at the bus to distribute equally
    ngg = Cg*np.transpose(np.sum(Cg, axis=2))   ## ngon x 1, number of gens at this gen's bus
    gen[onon, 2] = np.array(gen[onon, 2].toarray()/ngg).reshape(-1)

    ## set finite proxy M for infinite limits(for ~ proportional splitting)
    ## equal to sum over all gens at bus of abs(Qg) plus any finite Q limits
    Qmin = gen[onon, 4]
    Qmax = gen[onon, 3]
    M = abs(gen[onon, 2])
    idx1 = np.isinf(Qmax.toarray())
    idx1 = np.where(idx1 == False)[0]
    idx2 = np.isinf(Qmin.toarray())
    idx2 = np.where(idx2 == False)[0]

    M[idx1] = M[idx1] + abs(Qmax[idx1])
    M[idx2] = M[idx2] + abs(Qmax[idx2])
    M = Cg*np.transpose(Cg)*M  ## each gen gets sum over all gens at same bus

    ## replace + / - Inf limits with proxy +/ - M
    Qmin[Qmin == np.Inf] = M[Qmin == np.Inf]
    Qmin[Qmin == -np.Inf] = -M[Qmin == -np.Inf]
    Qmax[Qmax == np.Inf] = M[Qmax == np.Inf]
    Qmax[Qmax == -np.Inf] = -M[Qmax == -np.Inf]

    ## divide proportionally
    Cmin = csc_matrix((Qmin.toarray().reshape(-1), (data, ggbus.reshape(-1))), shape=(ngon, nb))
    Cmax = csc_matrix((Qmax.toarray().reshape(-1), (data, ggbus.reshape(-1))), shape=(ngon, nb))
    Qg_tot = np.transpose(Cg)*gen[onon, 2]           ## nbx1 vector of total Qg at each bus
    Qg_min = np.transpose(np.sum(Cmin, axis=2))      ## nbx1 vector of min total Qg at each bus
    Qg_max = np.transpose(np.sum(Cmax, axis=2))      ## nbx1 vector of max total Qg at each bus

    a = (Cg*((Qg_tot - Qg_min)/(Qg_max - Qg_min + np.finfo(float).eps)))
    a = np.array(a)
    b = (Qmax.toarray() - Qmin.toarray())
    gen[onon, 2] = (Qmin.toarray() + a*b).reshape(-1)  ## avoid div by 0

    ## fix gens at buses with Qg range = 0 (use equal violation for all)
    ig = np.where(abs(Cg * (Qg_min - Qg_max)) < 10*np.finfo(float).eps)[0] ##  gens at buses with Qg range = 0
    if len(ig) > 0:
        ib = np.where(np.transpose(np.sum(Cg[ig,:], axis=2)))[0]   ## buses with Qg range = 0
        ## total mismatch @ bus div by number of gens
        c = ((Qg_tot[ib] - Qg_min[ib])/np.sum(np.transpose(Cg[:, ib]), axis=1))
        c = np.array(c)
        mis = np.zeros((nb,1))
        mis[ib] = c
        gen[onon[ig], 2] = np.array(Qmin[ig] + Cg[ig,:]*mis).reshape(-1)

    ## update Pg for slack gen(s)
    for k in range(0,len(ref)):
        refgen = np.where(ggbus == ref[k])[0]       ## which is (are) the reference gen(s)?
        Pd_refk = bus[ref[k], 2].reshape(-1)
        gen[onon[refgen[0]], 1] = Sinj[refgen[0]].real*baseMVA + Pd_refk   ## inj P + local Pd

        if len(refgen) > 1:   ## more than one generator at this ref bus
            ## subtract off what is generated by other gens at this bus
            gen[onon[refgen[0]], 1] = gen[onon[refgen[0]], PG] - np.sum(gen[onon[refgen[1:len(refgen)]], 1], axis=2)

    pg_sol = gen[:,1].toarray().reshape(-1) / baseMVA
    qg_sol = gen[:,2].toarray().reshape(-1) / baseMVA

    return pg_sol, qg_sol


